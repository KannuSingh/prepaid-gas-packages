# React Integration Examples

Frontend integration patterns with React, hooks, and modern Web3 libraries.

## Basic React Setup

### Context Provider

```typescript
// contexts/PaymasterContext.tsx
import React, { createContext, useContext, useEffect, useState, ReactNode } from 'react'
import { PrepaidGasPaymaster } from '@prepaid-gas/core'
import { SubgraphClient } from '@prepaid-gas/data'
import { useChainId } from 'wagmi'

interface PaymasterContextType {
  paymaster: PrepaidGasPaymaster | null
  subgraphClient: SubgraphClient | null
  isLoading: boolean
  error: string | null
}

const PaymasterContext = createContext<PaymasterContextType>({
  paymaster: null,
  subgraphClient: null,
  isLoading: true,
  error: null
})

export function PaymasterProvider({ children }: { children: ReactNode }) {
  const chainId = useChainId()
  const [paymaster, setPaymaster] = useState<PrepaidGasPaymaster | null>(null)
  const [subgraphClient, setSubgraphClient] = useState<SubgraphClient | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  
  useEffect(() => {
    async function initializeClients() {
      try {
        setIsLoading(true)
        setError(null)
        
        const supportedChains = [84532] // Base Sepolia
        
        if (!supportedChains.includes(chainId)) {
          throw new Error(`Unsupported chain: ${chainId}`)
        }
        
        const paymasterClient = PrepaidGasPaymaster.createForNetwork(chainId)
        const subgraphClientInstance = SubgraphClient.createForNetwork(chainId)
        
        setPaymaster(paymasterClient)
        setSubgraphClient(subgraphClientInstance)
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to initialize clients')
        setPaymaster(null)
        setSubgraphClient(null)
      } finally {
        setIsLoading(false)
      }
    }
    
    initializeClients()
  }, [chainId])
  
  return (
    <PaymasterContext.Provider value={{ paymaster, subgraphClient, isLoading, error }}>
      {children}
    </PaymasterContext.Provider>
  )
}

export function usePaymaster() {
  const context = useContext(PaymasterContext)
  if (!context) {
    throw new Error('usePaymaster must be used within PaymasterProvider')
  }
  return context
}
```

### Custom Hooks

```typescript
// hooks/usePaymasterData.ts
import { useState, useCallback } from 'react'
import { usePaymaster } from '../contexts/PaymasterContext'
import { Identity } from '@semaphore-protocol/identity'
import { ValidationError, PaymasterError } from '@prepaid-gas/core'

interface UsePaymasterDataResult {
  generatePaymasterData: (params: {
    userOp: any
    poolId: string
    identity: Identity
  }) => Promise<any>
  estimateGas: (params: {
    userOp: any
    poolId: string
  }) => Promise<any>
  isLoading: boolean
  error: string | null
}

export function usePaymasterData(): UsePaymasterDataResult {
  const { paymaster } = usePaymaster()
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  
  const generatePaymasterData = useCallback(async (params: {
    userOp: any
    poolId: string
    identity: Identity
  }) => {
    if (!paymaster) {
      throw new Error('Paymaster not initialized')
    }
    
    setIsLoading(true)
    setError(null)
    
    try {
      const result = await paymaster.getPaymasterData({
        userOp: params.userOp,
        poolId: params.poolId,
        identity: params.identity.export()
      })
      
      return result
    } catch (err) {
      let errorMessage = 'Failed to generate paymaster data'
      
      if (err instanceof ValidationError) {
        errorMessage = `Validation error: ${err.message}`
      } else if (err instanceof PaymasterError) {
        errorMessage = `Paymaster error: ${err.message}`
      } else if (err instanceof Error) {
        errorMessage = err.message
      }
      
      setError(errorMessage)
      throw err
    } finally {
      setIsLoading(false)
    }
  }, [paymaster])
  
  const estimateGas = useCallback(async (params: {
    userOp: any
    poolId: string
  }) => {
    if (!paymaster) {
      throw new Error('Paymaster not initialized')
    }
    
    setIsLoading(true)
    setError(null)
    
    try {
      const result = await paymaster.getPaymasterStubData({
        userOp: params.userOp,
        poolId: params.poolId,
        identity: 'dummy'
      })
      
      return result
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to estimate gas'
      setError(errorMessage)
      throw err
    } finally {
      setIsLoading(false)
    }
  }, [paymaster])
  
  return {
    generatePaymasterData,
    estimateGas,
    isLoading,
    error
  }
}
```

```typescript
// hooks/usePools.ts
import { useQuery } from '@tanstack/react-query'
import { usePaymaster } from '../contexts/PaymasterContext'

export function usePools(options: {
  minAnonymitySet?: number
  includeMembers?: boolean
  enabled?: boolean
} = {}) {
  const { subgraphClient } = usePaymaster()
  const { minAnonymitySet = 10, includeMembers = false, enabled = true } = options
  
  return useQuery({
    queryKey: ['pools', minAnonymitySet, includeMembers],
    queryFn: async () => {
      if (!subgraphClient) {
        throw new Error('Subgraph client not initialized')
      }
      
      let query = subgraphClient.query()
        .pools()
        .byNetwork('base-sepolia')
        .orderBy('memberCount', 'desc')
        .first(50)
      
      if (includeMembers) {
        query = query.withMembers(100)
      }
      
      const pools = await query.executeAndSerialize()
      
      // Filter by minimum anonymity set
      return pools.filter(pool => pool.memberCount >= minAnonymitySet)
    },
    enabled: enabled && !!subgraphClient,
    staleTime: 2 * 60 * 1000, // 2 minutes
    refetchInterval: 5 * 60 * 1000, // 5 minutes
  })
}

export function usePoolDetails(poolId: string | undefined) {
  const { subgraphClient } = usePaymaster()
  
  return useQuery({
    queryKey: ['pool-details', poolId],
    queryFn: async () => {
      if (!subgraphClient || !poolId) {
        throw new Error('Missing dependencies')
      }
      
      const pools = await subgraphClient.query()
        .pools()
        .byId(`base-sepolia-${poolId}`)
        .withMembers()
        .withTransactions(20)
        .executeAndSerialize()
      
      return pools[0] || null
    },
    enabled: !!subgraphClient && !!poolId,
    staleTime: 1 * 60 * 1000, // 1 minute
  })
}
```

## Component Examples

### Pool Selector Component

```typescript
// components/PoolSelector.tsx
import React, { useState } from 'react'
import { usePools } from '../hooks/usePools'

interface Pool {
  poolId: string
  memberCount: number
  paymasterAddress: string
  totalDeposited: string
}

interface PoolSelectorProps {
  onPoolSelect: (pool: Pool) => void
  selectedPoolId?: string
  minAnonymitySet?: number
}

export function PoolSelector({ 
  onPoolSelect, 
  selectedPoolId, 
  minAnonymitySet = 20 
}: PoolSelectorProps) {
  const { data: pools, isLoading, error } = usePools({ 
    minAnonymitySet,
    includeMembers: true 
  })
  
  if (isLoading) {
    return (
      <div className="animate-pulse">
        <div className="h-4 bg-gray-200 rounded w-1/4 mb-4"></div>
        <div className="space-y-2">
          {[...Array(3)].map((_, i) => (
            <div key={i} className="h-16 bg-gray-200 rounded"></div>
          ))}
        </div>
      </div>
    )
  }
  
  if (error) {
    return (
      <div className="bg-red-50 border border-red-200 rounded-md p-4">
        <p className="text-red-700">Failed to load pools: {error.message}</p>
      </div>
    )
  }
  
  if (!pools || pools.length === 0) {
    return (
      <div className="bg-yellow-50 border border-yellow-200 rounded-md p-4">
        <p className="text-yellow-700">
          No pools found with minimum anonymity set of {minAnonymitySet} members.
        </p>
      </div>
    )
  }
  
  return (
    <div className="space-y-2">
      <label className="block text-sm font-medium text-gray-700 mb-2">
        Select Privacy Pool
      </label>
      
      <div className="space-y-2">
        {pools.map((pool) => (
          <div
            key={pool.poolId}
            className={`
              border rounded-lg p-4 cursor-pointer transition-colors
              ${selectedPoolId === pool.poolId 
                ? 'border-blue-500 bg-blue-50' 
                : 'border-gray-200 hover:border-gray-300 hover:bg-gray-50'
              }
            `}
            onClick={() => onPoolSelect(pool)}
          >
            <div className="flex justify-between items-start">
              <div>
                <h3 className="font-medium text-gray-900">
                  Pool #{pool.poolId}
                </h3>
                <p className="text-sm text-gray-600">
                  {pool.memberCount} members
                </p>
              </div>
              
              <div className="text-right">
                <PrivacyScore memberCount={pool.memberCount} />
                <p className="text-xs text-gray-500 mt-1">
                  {formatEther(pool.totalDeposited)} ETH deposited
                </p>
              </div>
            </div>
          </div>
        ))}
      </div>
    </div>
  )
}

function PrivacyScore({ memberCount }: { memberCount: number }) {
  const getScoreColor = (count: number) => {
    if (count >= 100) return 'text-green-600'
    if (count >= 50) return 'text-yellow-600'
    return 'text-red-600'
  }
  
  const getScoreLabel = (count: number) => {
    if (count >= 100) return 'Excellent'
    if (count >= 50) return 'Good'
    if (count >= 20) return 'Fair'
    return 'Poor'
  }
  
  return (
    <span className={`text-sm font-medium ${getScoreColor(memberCount)}`}>
      {getScoreLabel(memberCount)} Privacy
    </span>
  )
}

function formatEther(wei: string): string {
  // Simple ETH formatting - use ethers.js in production
  const eth = BigInt(wei) / BigInt(10 ** 18)
  return eth.toString()
}
```

### Transaction Component

```typescript
// components/PaymasterTransaction.tsx
import React, { useState } from 'react'
import { Identity } from '@semaphore-protocol/identity'
import { usePaymasterData } from '../hooks/usePaymasterData'
import { useAccount } from 'wagmi'

interface PaymasterTransactionProps {
  userOp: any
  poolId: string
  identity: Identity
  onSuccess: (result: any) => void
  onError: (error: Error) => void
}

export function PaymasterTransaction({
  userOp,
  poolId,
  identity,
  onSuccess,
  onError
}: PaymasterTransactionProps) {
  const { generatePaymasterData, estimateGas, isLoading, error } = usePaymasterData()
  const [step, setStep] = useState<'estimate' | 'generate' | 'submit'>('estimate')
  const [gasEstimate, setGasEstimate] = useState<any>(null)
  const [paymasterData, setPaymasterData] = useState<any>(null)
  
  const handleEstimateGas = async () => {
    try {
      setStep('estimate')
      const estimate = await estimateGas({ userOp, poolId })
      setGasEstimate(estimate)
    } catch (err) {
      onError(err instanceof Error ? err : new Error('Gas estimation failed'))
    }
  }
  
  const handleGenerateProof = async () => {
    try {
      setStep('generate')
      const data = await generatePaymasterData({ userOp, poolId, identity })
      setPaymasterData(data)
      onSuccess(data)
    } catch (err) {
      onError(err instanceof Error ? err : new Error('Proof generation failed'))
    }
  }
  
  return (
    <div className="bg-white border border-gray-200 rounded-lg p-6">
      <h3 className="text-lg font-medium text-gray-900 mb-4">
        Privacy Transaction
      </h3>
      
      {/* Step Indicator */}
      <div className="flex items-center space-x-4 mb-6">
        <StepIndicator 
          step={1} 
          label="Estimate Gas" 
          isActive={step === 'estimate'} 
          isCompleted={!!gasEstimate}
        />
        <StepIndicator 
          step={2} 
          label="Generate Proof" 
          isActive={step === 'generate'} 
          isCompleted={!!paymasterData}
        />
        <StepIndicator 
          step={3} 
          label="Submit Transaction" 
          isActive={step === 'submit'} 
          isCompleted={false}
        />
      </div>
      
      {/* Error Display */}
      {error && (
        <div className="bg-red-50 border border-red-200 rounded-md p-4 mb-4">
          <p className="text-red-700">{error}</p>
        </div>
      )}
      
      {/* Gas Estimate */}
      {gasEstimate && (
        <div className="bg-blue-50 border border-blue-200 rounded-md p-4 mb-4">
          <h4 className="font-medium text-blue-900 mb-2">Gas Estimate</h4>
          <div className="text-sm text-blue-700 space-y-1">
            <p>Call Gas: {gasEstimate.callGasLimit.toString()}</p>
            <p>Verification Gas: {gasEstimate.verificationGasLimit.toString()}</p>
            <p>Paymaster Gas: {gasEstimate.paymasterVerificationGasLimit.toString()}</p>
          </div>
        </div>
      )}
      
      {/* Action Buttons */}
      <div className="flex space-x-3">
        {!gasEstimate && (
          <button
            onClick={handleEstimateGas}
            disabled={isLoading}
            className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:opacity-50"
          >
            {isLoading && step === 'estimate' ? 'Estimating...' : 'Estimate Gas'}
          </button>
        )}
        
        {gasEstimate && !paymasterData && (
          <button
            onClick={handleGenerateProof}
            disabled={isLoading}
            className="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 disabled:opacity-50"
          >
            {isLoading && step === 'generate' ? (
              <div className="flex items-center space-x-2">
                <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></div>
                <span>Generating ZK Proof...</span>
              </div>
            ) : (
              'Generate Proof'
            )}
          </button>
        )}
        
        {paymasterData && (
          <div className="bg-green-50 border border-green-200 rounded-md p-4">
            <p className="text-green-700 font-medium">
              ✓ Paymaster data generated successfully!
            </p>
            <p className="text-green-600 text-sm">
              Transaction is ready to submit.
            </p>
          </div>
        )}
      </div>
    </div>
  )
}

function StepIndicator({ 
  step, 
  label, 
  isActive, 
  isCompleted 
}: {
  step: number
  label: string
  isActive: boolean
  isCompleted: boolean
}) {
  return (
    <div className="flex items-center">
      <div className={`
        rounded-full w-8 h-8 flex items-center justify-center text-sm font-medium
        ${isCompleted 
          ? 'bg-green-600 text-white' 
          : isActive 
            ? 'bg-blue-600 text-white' 
            : 'bg-gray-200 text-gray-600'
        }
      `}>
        {isCompleted ? '✓' : step}
      </div>
      <span className={`ml-2 text-sm ${isActive ? 'font-medium' : ''}`}>
        {label}
      </span>
    </div>
  )
}
```

### Identity Management Component

```typescript
// components/IdentityManager.tsx
import React, { useState, useEffect } from 'react'
import { Identity } from '@semaphore-protocol/identity'

interface StoredIdentity {
  id: string
  commitment: string
  createdAt: number
  label: string
}

export function IdentityManager() {
  const [identities, setIdentities] = useState<StoredIdentity[]>([])
  const [selectedIdentity, setSelectedIdentity] = useState<Identity | null>(null)
  const [showCreateForm, setShowCreateForm] = useState(false)
  
  useEffect(() => {
    loadStoredIdentities()
  }, [])
  
  const loadStoredIdentities = () => {
    const stored = localStorage.getItem('prepaid-gas-identities')
    if (stored) {
      setIdentities(JSON.parse(stored))
    }
  }
  
  const saveIdentities = (newIdentities: StoredIdentity[]) => {
    localStorage.setItem('prepaid-gas-identities', JSON.stringify(newIdentities))
    setIdentities(newIdentities)
  }
  
  const createNewIdentity = (label: string) => {
    const identity = new Identity()
    const newStoredIdentity: StoredIdentity = {
      id: crypto.randomUUID(),
      commitment: identity.commitment.toString(),
      createdAt: Date.now(),
      label
    }
    
    // Store the exported identity securely (in production, use encrypted storage)
    localStorage.setItem(`identity-${newStoredIdentity.id}`, identity.export())
    
    const updatedIdentities = [...identities, newStoredIdentity]
    saveIdentities(updatedIdentities)
    setSelectedIdentity(identity)
    setShowCreateForm(false)
  }
  
  const loadIdentity = (storedIdentity: StoredIdentity) => {
    const exported = localStorage.getItem(`identity-${storedIdentity.id}`)
    if (exported) {
      const identity = Identity.import(exported)
      setSelectedIdentity(identity)
    }
  }
  
  const deleteIdentity = (id: string) => {
    const updatedIdentities = identities.filter(i => i.id !== id)
    saveIdentities(updatedIdentities)
    localStorage.removeItem(`identity-${id}`)
    
    if (selectedIdentity && identities.find(i => i.id === id)) {
      setSelectedIdentity(null)
    }
  }
  
  return (
    <div className="bg-white border border-gray-200 rounded-lg p-6">
      <div className="flex justify-between items-center mb-4">
        <h3 className="text-lg font-medium text-gray-900">
          Identity Management
        </h3>
        <button
          onClick={() => setShowCreateForm(true)}
          className="px-3 py-1 bg-blue-600 text-white text-sm rounded-md hover:bg-blue-700"
        >
          New Identity
        </button>
      </div>
      
      {/* Selected Identity Display */}
      {selectedIdentity && (
        <div className="bg-green-50 border border-green-200 rounded-md p-4 mb-4">
          <h4 className="font-medium text-green-900 mb-2">Selected Identity</h4>
          <p className="text-green-700 text-sm font-mono break-all">
            {selectedIdentity.commitment.toString()}
          </p>
        </div>
      )}
      
      {/* Create Form */}
      {showCreateForm && (
        <CreateIdentityForm
          onCreate={createNewIdentity}
          onCancel={() => setShowCreateForm(false)}
        />
      )}
      
      {/* Identity List */}
      <div className="space-y-2">
        {identities.map((identity) => (
          <div
            key={identity.id}
            className="border border-gray-200 rounded-md p-3 flex justify-between items-center"
          >
            <div className="flex-1">
              <h4 className="font-medium text-gray-900">{identity.label}</h4>
              <p className="text-sm text-gray-600 font-mono">
                {identity.commitment.slice(0, 20)}...
              </p>
              <p className="text-xs text-gray-500">
                Created {new Date(identity.createdAt).toLocaleDateString()}
              </p>
            </div>
            
            <div className="flex space-x-2">
              <button
                onClick={() => loadIdentity(identity)}
                className="px-3 py-1 bg-blue-600 text-white text-sm rounded hover:bg-blue-700"
              >
                Select
              </button>
              <button
                onClick={() => deleteIdentity(identity.id)}
                className="px-3 py-1 bg-red-600 text-white text-sm rounded hover:bg-red-700"
              >
                Delete
              </button>
            </div>
          </div>
        ))}
      </div>
      
      {identities.length === 0 && !showCreateForm && (
        <p className="text-gray-500 text-center py-8">
          No identities found. Create one to get started.
        </p>
      )}
    </div>
  )
}

function CreateIdentityForm({
  onCreate,
  onCancel
}: {
  onCreate: (label: string) => void
  onCancel: () => void
}) {
  const [label, setLabel] = useState('')
  
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    if (label.trim()) {
      onCreate(label.trim())
    }
  }
  
  return (
    <form onSubmit={handleSubmit} className="bg-gray-50 border border-gray-200 rounded-md p-4 mb-4">
      <h4 className="font-medium text-gray-900 mb-3">Create New Identity</h4>
      
      <div className="mb-3">
        <label className="block text-sm font-medium text-gray-700 mb-1">
          Identity Label
        </label>
        <input
          type="text"
          value={label}
          onChange={(e) => setLabel(e.target.value)}
          placeholder="e.g., Main Identity, Pool 1 Identity"
          className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
          required
        />
      </div>
      
      <div className="flex space-x-2">
        <button
          type="submit"
          className="px-4 py-2 bg-green-600 text-white text-sm rounded-md hover:bg-green-700"
        >
          Create
        </button>
        <button
          type="button"
          onClick={onCancel}
          className="px-4 py-2 bg-gray-600 text-white text-sm rounded-md hover:bg-gray-700"
        >
          Cancel
        </button>
      </div>
    </form>
  )
}
```

## Complete App Example

### Main App Component

```typescript
// App.tsx
import React from 'react'
import { WagmiConfig } from 'wagmi'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { PaymasterProvider } from './contexts/PaymasterContext'
import { PaymasterApp } from './components/PaymasterApp'
import { wagmiConfig } from './config/wagmi'

const queryClient = new QueryClient()

export default function App() {
  return (
    <WagmiConfig config={wagmiConfig}>
      <QueryClientProvider client={queryClient}>
        <PaymasterProvider>
          <div className="min-h-screen bg-gray-50">
            <header className="bg-white shadow">
              <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                <div className="flex justify-between h-16">
                  <div className="flex items-center">
                    <h1 className="text-xl font-semibold">
                      Prepaid Gas Demo
                    </h1>
                  </div>
                  <div className="flex items-center">
                    <button className="px-4 py-2 bg-blue-600 text-white rounded">
                      Connect Wallet
                    </button>
                  </div>
                </div>
              </div>
            </header>
            
            <main className="max-w-7xl mx-auto py-6 sm:px-6 lg:px-8">
              <PaymasterApp />
            </main>
          </div>
        </PaymasterProvider>
      </QueryClientProvider>
    </WagmiConfig>
  )
}
```

```typescript
// components/PaymasterApp.tsx
import React, { useState } from 'react'
import { Identity } from '@semaphore-protocol/identity'
import { PoolSelector } from './PoolSelector'
import { IdentityManager } from './IdentityManager'
import { PaymasterTransaction } from './PaymasterTransaction'
import { useAccount } from 'wagmi'

export function PaymasterApp() {
  const { isConnected } = useAccount()
  const [selectedPool, setSelectedPool] = useState<any>(null)
  const [selectedIdentity, setSelectedIdentity] = useState<Identity | null>(null)
  const [transactionResult, setTransactionResult] = useState<any>(null)
  
  if (!isConnected) {
    return (
      <div className="text-center py-12">
        <h2 className="text-2xl font-bold text-gray-900 mb-4">
          Connect Your Wallet
        </h2>
        <p className="text-gray-600 mb-8">
          Connect your wallet to start using privacy-preserving gas payments.
        </p>
        <button className="px-6 py-3 bg-blue-600 text-white rounded-lg">
          Connect Wallet
        </button>
      </div>
    )
  }
  
  const mockUserOp = {
    sender: '0x1234567890123456789012345678901234567890',
    nonce: 0n,
    callData: '0x',
    callGasLimit: 100000n,
    verificationGasLimit: 100000n,
    preVerificationGas: 21000n,
    maxFeePerGas: 1000000000n,
    maxPriorityFeePerGas: 1000000000n,
    signature: '0x'
  }
  
  return (
    <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
      {/* Left Column */}
      <div className="space-y-6">
        <IdentityManager
          selectedIdentity={selectedIdentity}
          onIdentitySelect={setSelectedIdentity}
        />
        
        <PoolSelector
          onPoolSelect={setSelectedPool}
          selectedPoolId={selectedPool?.poolId}
          minAnonymitySet={20}
        />
      </div>
      
      {/* Right Column */}
      <div className="space-y-6">
        {selectedPool && selectedIdentity ? (
          <PaymasterTransaction
            userOp={mockUserOp}
            poolId={selectedPool.poolId}
            identity={selectedIdentity}
            onSuccess={(result) => {
              setTransactionResult(result)
              console.log('Transaction successful:', result)
            }}
            onError={(error) => {
              console.error('Transaction failed:', error)
            }}
          />
        ) : (
          <div className="bg-gray-50 border border-gray-200 rounded-lg p-8 text-center">
            <h3 className="text-lg font-medium text-gray-900 mb-2">
              Ready to Transact
            </h3>
            <p className="text-gray-600">
              {!selectedIdentity && !selectedPool && 'Select an identity and pool to begin'}
              {!selectedIdentity && selectedPool && 'Select an identity to continue'}
              {selectedIdentity && !selectedPool && 'Select a pool to continue'}
            </p>
          </div>
        )}
        
        {transactionResult && (
          <div className="bg-green-50 border border-green-200 rounded-lg p-6">
            <h3 className="text-lg font-medium text-green-900 mb-4">
              Transaction Successful!
            </h3>
            <div className="space-y-2 text-sm">
              <p><strong>Pool Used:</strong> {selectedPool.poolId}</p>
              <p><strong>Gas Limit:</strong> {transactionResult.callGasLimit?.toString()}</p>
              <p><strong>Is Final:</strong> {transactionResult.isFinal ? 'Yes' : 'No'}</p>
            </div>
          </div>
        )}
      </div>
    </div>
  )
}
```

This React integration provides a complete example of how to build a user-friendly interface for the Prepaid Gas SDK, including proper state management, error handling, and user feedback.