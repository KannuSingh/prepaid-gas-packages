# Privacy Best Practices

Understanding and optimizing privacy in the Prepaid Gas system.

## Privacy Model Overview

The Prepaid Gas system provides **pool-based anonymity** using zero-knowledge proofs. Understanding the privacy guarantees and limitations is crucial for optimal privacy.

### Core Privacy Concepts

**Anonymity Set**: The group of users among whom you are indistinguishable. Larger pools provide stronger anonymity.

**Linkability**: Transactions that can be connected to the same user identity.

**Unlinkability**: Transactions that cannot be connected, even if made by the same person.

## Privacy Guarantees

### What is Private

✅ **Identity within Pool**: Your specific identity is hidden among all pool members  
✅ **Transaction Content**: What you're doing in your transaction remains private  
✅ **Gas Payment Source**: Which pool member paid for gas is unknown  
✅ **Cross-Pool Privacy**: Using different identities across pools provides unlinkability  

### What is NOT Private

❌ **Pool Membership**: It's visible that you joined a specific pool  
❌ **Transaction Timing**: When transactions occur is visible  
❌ **Pool Selection**: Which pools you choose to use  
❌ **Transaction Metadata**: Gas amounts, contract interactions  

## Identity Management

### Single vs Multiple Identities

**Single Identity Across Pools** (Linkable):
```typescript
// ❌ Same identity used across pools = linkable transactions
const identity = new Identity()

// All these transactions are linkable
await paymaster.getPaymasterData({ poolId: '1', identity: identity.export() })
await paymaster.getPaymasterData({ poolId: '2', identity: identity.export() })
await paymaster.getPaymasterData({ poolId: '3', identity: identity.export() })
```

**Multiple Identities** (Unlinkable):
```typescript
// ✅ Different identities for maximum privacy
const identityPool1 = new Identity()
const identityPool2 = new Identity()  
const identityPool3 = new Identity()

// These transactions are unlinkable
await paymaster.getPaymasterData({ poolId: '1', identity: identityPool1.export() })
await paymaster.getPaymasterData({ poolId: '2', identity: identityPool2.export() })
await paymaster.getPaymasterData({ poolId: '3', identity: identityPool3.export() })
```

### Identity Storage Strategy

```typescript
// utils/privacy-identity-manager.ts
import { Identity } from '@semaphore-protocol/identity'

export class PrivacyIdentityManager {
  private identities = new Map<string, Identity>()
  
  // Generate unique identity for each pool
  getOrCreateIdentityForPool(poolId: string): Identity {
    const key = `pool-${poolId}`
    
    if (!this.identities.has(key)) {
      const identity = new Identity()
      this.identities.set(key, identity)
      
      // Store securely (encrypted)
      this.secureStore(key, identity.export())
    }
    
    return this.identities.get(key)!
  }
  
  // Generate identity for specific use case
  createContextualIdentity(context: string): Identity {
    const identity = new Identity()
    const key = `context-${context}-${Date.now()}`
    
    this.identities.set(key, identity)
    this.secureStore(key, identity.export())
    
    return identity
  }
  
  private secureStore(key: string, exported: string) {
    // Implement secure storage (encrypted)
    // Consider using IndexedDB with encryption for browser
    // Or encrypted file storage for server
  }
}
```

## Pool Selection Strategy

### Analyzing Pool Privacy

```typescript
// utils/privacy-analyzer.ts
import { SubgraphClient } from '@prepaid-gas/data'

export class PoolPrivacyAnalyzer {
  constructor(private client: SubgraphClient) {}
  
  async analyzePoolPrivacy(poolId: string) {
    const pools = await this.client.query()
      .pools()
      .byId(`base-sepolia-${poolId}`)
      .withMembers()
      .withTransactions(100)
      .executeAndSerialize()
    
    if (pools.length === 0) {
      throw new Error('Pool not found')
    }
    
    const pool = pools[0]
    
    return {
      anonymitySet: pool.memberCount,
      privacyScore: this.calculatePrivacyScore(pool),
      recommendations: this.generateRecommendations(pool),
      recentActivity: pool.transactions?.length || 0
    }
  }
  
  private calculatePrivacyScore(pool: any): number {
    const memberCount = pool.memberCount
    const recentTxs = pool.transactions?.length || 0
    
    // Score based on anonymity set size and activity
    let score = 0
    
    // Member count scoring (0-50 points)
    if (memberCount >= 100) score += 50
    else if (memberCount >= 50) score += 35
    else if (memberCount >= 20) score += 20
    else if (memberCount >= 10) score += 10
    
    // Activity scoring (0-30 points)
    if (recentTxs >= 50) score += 30
    else if (recentTxs >= 20) score += 20
    else if (recentTxs >= 10) score += 10
    else if (recentTxs >= 5) score += 5
    
    // Pool age and distribution (0-20 points)
    // Additional factors could include:
    // - Member join distribution over time
    // - Transaction timing patterns
    // - Pool creation age
    score += 20 // Placeholder
    
    return Math.min(score, 100)
  }
  
  private generateRecommendations(pool: any): string[] {
    const recommendations: string[] = []
    
    if (pool.memberCount < 10) {
      recommendations.push('Consider waiting for more members to join this pool')
    }
    
    if (pool.memberCount < 50) {
      recommendations.push('Look for pools with larger anonymity sets for better privacy')
    }
    
    if ((pool.transactions?.length || 0) === 0) {
      recommendations.push('This pool has no recent activity - consider more active pools')
    }
    
    if (pool.memberCount > 100 && (pool.transactions?.length || 0) > 20) {
      recommendations.push('This pool provides strong privacy guarantees')
    }
    
    return recommendations
  }
}

// Usage
const analyzer = new PoolPrivacyAnalyzer(subgraphClient)
const analysis = await analyzer.analyzePoolPrivacy('1')

console.log(`Privacy Score: ${analysis.privacyScore}/100`)
console.log('Recommendations:', analysis.recommendations)
```

### Smart Pool Selection

```typescript
// utils/smart-pool-selector.ts
export class SmartPoolSelector {
  constructor(private client: SubgraphClient) {}
  
  async findOptimalPool(criteria: {
    minAnonymitySet?: number
    minActivity?: number
    excludePools?: string[]
  } = {}) {
    const { 
      minAnonymitySet = 20, 
      minActivity = 5,
      excludePools = []
    } = criteria
    
    const pools = await this.client.query()
      .pools()
      .byNetwork('base-sepolia')
      .withMembers()
      .withTransactions(50)
      .orderBy('memberCount', 'desc')
      .first(50)
      .executeAndSerialize()
    
    const eligiblePools = pools.filter(pool => {
      const recentActivity = pool.transactions?.length || 0
      
      return pool.memberCount >= minAnonymitySet &&
             recentActivity >= minActivity &&
             !excludePools.includes(pool.poolId)
    })
    
    if (eligiblePools.length === 0) {
      throw new Error('No pools meet privacy criteria')
    }
    
    // Score pools and return best option
    const scoredPools = eligiblePools.map(pool => ({
      pool,
      score: this.scorePool(pool)
    }))
    
    scoredPools.sort((a, b) => b.score - a.score)
    
    return {
      recommended: scoredPools[0].pool,
      alternatives: scoredPools.slice(1, 4).map(p => p.pool),
      analysis: {
        totalEligible: eligiblePools.length,
        averageAnonymitySet: Math.round(
          eligiblePools.reduce((sum, p) => sum + p.memberCount, 0) / eligiblePools.length
        )
      }
    }
  }
  
  private scorePool(pool: any): number {
    const memberScore = Math.min(pool.memberCount / 100, 1) * 50
    const activityScore = Math.min((pool.transactions?.length || 0) / 20, 1) * 30
    
    // Add randomness to avoid predictable selection
    const randomScore = Math.random() * 20
    
    return memberScore + activityScore + randomScore
  }
}

// Usage
const selector = new SmartPoolSelector(subgraphClient)
const recommendation = await selector.findOptimalPool({
  minAnonymitySet: 50,
  minActivity: 10
})

console.log('Recommended pool:', recommendation.recommended.poolId)
console.log('Privacy score:', recommendation.recommended.memberCount, 'members')
```

## Transaction Privacy Patterns

### Timing Considerations

```typescript
// utils/timing-privacy.ts
export class TimingPrivacyHelper {
  // Add random delay to mask transaction timing patterns
  static async randomDelay(minMs = 1000, maxMs = 5000): Promise<void> {
    const delay = Math.floor(Math.random() * (maxMs - minMs + 1)) + minMs
    await new Promise(resolve => setTimeout(resolve, delay))
  }
  
  // Batch transactions to hide individual timing
  static async batchTransactions(
    transactions: Array<() => Promise<any>>,
    batchSize = 3
  ): Promise<any[]> {
    const results: any[] = []
    
    for (let i = 0; i < transactions.length; i += batchSize) {
      const batch = transactions.slice(i, i + batchSize)
      
      // Add random delay between batches
      if (i > 0) {
        await this.randomDelay(2000, 8000)
      }
      
      // Execute batch in parallel
      const batchResults = await Promise.all(
        batch.map(tx => tx())
      )
      
      results.push(...batchResults)
    }
    
    return results
  }
}
```

### Gas Amount Privacy

```typescript
// utils/gas-privacy.ts
export class GasPrivacyHelper {
  // Add random gas buffer to mask transaction patterns
  static addPrivacyBuffer(gasLimit: bigint): bigint {
    // Add 10-30% random buffer
    const bufferPercent = Math.floor(Math.random() * 21) + 10 // 10-30%
    const buffer = gasLimit * BigInt(bufferPercent) / 100n
    
    return gasLimit + buffer
  }
  
  // Normalize gas amounts to common values
  static normalizeGasLimit(gasLimit: bigint): bigint {
    const commonLimits = [
      100000n, 150000n, 200000n, 300000n, 500000n, 1000000n
    ]
    
    // Find the smallest common limit that's >= required gas
    const normalized = commonLimits.find(limit => limit >= gasLimit)
    
    return normalized || gasLimit
  }
}
```

## Privacy-First Integration

### Complete Privacy Setup

```typescript
// utils/privacy-integration.ts
export class PrivacyIntegration {
  private identityManager: PrivacyIdentityManager
  private poolSelector: SmartPoolSelector
  private analyzer: PoolPrivacyAnalyzer
  
  constructor(subgraphClient: SubgraphClient) {
    this.identityManager = new PrivacyIdentityManager()
    this.poolSelector = new SmartPoolSelector(subgraphClient)
    this.analyzer = new PoolPrivacyAnalyzer(subgraphClient)
  }
  
  async executePrivateTransaction(
    paymaster: PrepaidGasPaymaster,
    userOp: any,
    privacyLevel: 'standard' | 'high' | 'maximum' = 'standard'
  ) {
    // 1. Select optimal pool based on privacy level
    const poolCriteria = this.getPoolCriteria(privacyLevel)
    const poolRecommendation = await this.poolSelector.findOptimalPool(poolCriteria)
    const selectedPool = poolRecommendation.recommended
    
    // 2. Get or create appropriate identity
    const identity = this.getIdentityForPrivacyLevel(privacyLevel, selectedPool.poolId)
    
    // 3. Analyze privacy implications
    const privacyAnalysis = await this.analyzer.analyzePoolPrivacy(selectedPool.poolId)
    
    if (privacyAnalysis.privacyScore < this.getMinPrivacyScore(privacyLevel)) {
      throw new Error(`Pool privacy score too low: ${privacyAnalysis.privacyScore}`)
    }
    
    // 4. Add timing privacy
    await TimingPrivacyHelper.randomDelay()
    
    // 5. Execute transaction with privacy enhancements
    const paymasterData = await paymaster.getPaymasterData({
      userOp,
      poolId: selectedPool.poolId,
      identity: identity.export()
    })
    
    return {
      paymasterData,
      privacyAnalysis,
      poolInfo: selectedPool
    }
  }
  
  private getPoolCriteria(privacyLevel: string) {
    switch (privacyLevel) {
      case 'maximum':
        return { minAnonymitySet: 100, minActivity: 20 }
      case 'high':
        return { minAnonymitySet: 50, minActivity: 10 }
      case 'standard':
      default:
        return { minAnonymitySet: 20, minActivity: 5 }
    }
  }
  
  private getIdentityForPrivacyLevel(privacyLevel: string, poolId: string): Identity {
    switch (privacyLevel) {
      case 'maximum':
        // Always create new identity for maximum privacy
        return this.identityManager.createContextualIdentity(`max-privacy-${Date.now()}`)
      case 'high':
        // Use pool-specific identity
        return this.identityManager.getOrCreateIdentityForPool(poolId)
      case 'standard':
      default:
        // Can reuse identity across similar pools
        return this.identityManager.getOrCreateIdentityForPool('standard')
    }
  }
  
  private getMinPrivacyScore(privacyLevel: string): number {
    switch (privacyLevel) {
      case 'maximum': return 80
      case 'high': return 60
      case 'standard': return 40
      default: return 40
    }
  }
}

// Usage
const privacyIntegration = new PrivacyIntegration(subgraphClient)

const result = await privacyIntegration.executePrivateTransaction(
  paymaster,
  userOp,
  'high' // High privacy level
)

console.log('Transaction executed with privacy score:', result.privacyAnalysis.privacyScore)
```

## Privacy Monitoring

### Privacy Metrics Tracking

```typescript
// utils/privacy-metrics.ts
export class PrivacyMetrics {
  static trackPrivacyDecision(decision: {
    privacyLevel: string
    poolSize: number
    privacyScore: number
    identityReused: boolean
  }) {
    // Track privacy-related decisions for analysis
    console.log('Privacy decision:', decision)
    
    // Send to analytics service
    // analytics.track('privacy_decision', decision)
  }
  
  static auditPrivacyPractices(transactions: Array<{
    poolId: string
    identity: string
    timestamp: number
  }>) {
    // Analyze transaction patterns for privacy leaks
    const identityUsage = new Map<string, string[]>()
    
    transactions.forEach(tx => {
      if (!identityUsage.has(tx.identity)) {
        identityUsage.set(tx.identity, [])
      }
      identityUsage.get(tx.identity)!.push(tx.poolId)
    })
    
    const privacyIssues: string[] = []
    
    identityUsage.forEach((pools, identity) => {
      if (pools.length > 1) {
        privacyIssues.push(`Identity reused across pools: ${pools.join(', ')}`)
      }
    })
    
    return {
      totalTransactions: transactions.length,
      uniqueIdentities: identityUsage.size,
      privacyIssues,
      privacyScore: this.calculateOverallPrivacyScore(identityUsage)
    }
  }
  
  private static calculateOverallPrivacyScore(
    identityUsage: Map<string, string[]>
  ): number {
    let score = 100
    
    // Deduct points for identity reuse
    identityUsage.forEach(pools => {
      if (pools.length > 1) {
        score -= (pools.length - 1) * 10 // -10 points per additional pool
      }
    })
    
    return Math.max(score, 0)
  }
}
```

## Privacy Best Practices Summary

### ✅ Do

- **Use separate identities for different pools**
- **Choose pools with large anonymity sets (50+ members)**
- **Wait for pool activity before transacting**
- **Add random timing delays**
- **Monitor privacy scores regularly**
- **Rotate identities for maximum privacy**

### ❌ Don't

- **Reuse identities across pools**
- **Use pools with &lt;$10 members**
- **Create predictable transaction patterns**
- **Store identities in plain text**
- **Ignore privacy scores**
- **Use the same pool repeatedly**

### Privacy Levels Summary

| Level | Identity Strategy | Pool Requirements | Privacy Score |
|-------|------------------|-------------------|---------------|
| **Standard** | Pool-specific | 20+ members, 5+ recent txs | 40+ |
| **High** | Unique per pool | 50+ members, 10+ recent txs | 60+ |
| **Maximum** | Always new | 100+ members, 20+ recent txs | 80+ |

Choose the appropriate privacy level based on your specific use case and threat model.