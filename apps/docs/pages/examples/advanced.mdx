# Advanced Examples

Complex integration patterns and optimization techniques.

## Advanced Pool Management

### Intelligent Pool Selection

```typescript
import { PrepaidGasPaymaster } from '@prepaid-gas/core'
import { SubgraphClient } from '@prepaid-gas/data'

class AdvancedPoolManager {
  private subgraph: SubgraphClient
  private paymaster: PrepaidGasPaymaster
  private poolCache = new Map<string, any>()
  private cacheTimeout = 5 * 60 * 1000 // 5 minutes
  
  constructor(chainId: number) {
    this.subgraph = SubgraphClient.createForNetwork(chainId)
    this.paymaster = PrepaidGasPaymaster.createForNetwork(chainId)
  }
  
  async selectOptimalPool(criteria: {
    minAnonymitySet: number
    maxGasCost?: bigint
    excludePools?: string[]
    preferredActivity?: 'high' | 'medium' | 'low'
  }) {
    const { minAnonymitySet, maxGasCost, excludePools = [], preferredActivity = 'medium' } = criteria
    
    // Get cached pools or fetch fresh data
    const pools = await this.getCachedPools()
    
    // Filter pools based on criteria
    let eligiblePools = pools.filter(pool => {
      return pool.memberCount >= minAnonymitySet &&
             !excludePools.includes(pool.poolId)
    })
    
    // Score pools based on multiple factors
    const scoredPools = await Promise.all(
      eligiblePools.map(async pool => ({
        pool,
        score: await this.calculatePoolScore(pool, preferredActivity, maxGasCost)
      }))
    )
    
    // Sort by score (highest first)
    scoredPools.sort((a, b) => b.score - a.score)
    
    if (scoredPools.length === 0) {
      throw new Error('No pools meet the specified criteria')
    }
    
    return {
      selected: scoredPools[0].pool,
      alternatives: scoredPools.slice(1, 4).map(p => p.pool),
      analysis: {
        totalEligible: scoredPools.length,
        averageScore: scoredPools.reduce((sum, p) => sum + p.score, 0) / scoredPools.length,
        criteria: criteria
      }
    }
  }
  
  private async getCachedPools() {
    const cacheKey = 'all-pools'
    const cached = this.poolCache.get(cacheKey)
    
    if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
      return cached.data
    }
    
    const pools = await this.subgraph.query()
      .pools()
      .byNetwork('base-sepolia')
      .withMembers(200)
      .withTransactions(50)
      .orderBy('memberCount', 'desc')
      .first(100)
      .executeAndSerialize()
    
    this.poolCache.set(cacheKey, {
      data: pools,
      timestamp: Date.now()
    })
    
    return pools
  }
  
  private async calculatePoolScore(
    pool: any, 
    preferredActivity: string, 
    maxGasCost?: bigint
  ): Promise<number> {
    let score = 0
    
    // Anonymity set score (0-40 points)
    const anonymityScore = Math.min(pool.memberCount / 100 * 40, 40)
    score += anonymityScore
    
    // Activity score based on preference (0-30 points)
    const recentTxs = pool.transactions?.length || 0
    let activityScore = 0
    
    switch (preferredActivity) {
      case 'high':
        activityScore = Math.min(recentTxs / 20 * 30, 30)
        break
      case 'medium':
        activityScore = recentTxs >= 5 && recentTxs <= 15 ? 30 : Math.min(recentTxs / 10 * 20, 20)
        break
      case 'low':
        activityScore = recentTxs <= 5 ? 30 : Math.max(30 - (recentTxs - 5) * 2, 10)
        break
    }
    score += activityScore
    
    // Gas cost consideration (0-20 points)
    if (maxGasCost) {
      try {
        const gasEstimate = await this.estimatePoolGasCost(pool.poolId)
        const gasCostScore = gasEstimate <= maxGasCost ? 20 : Math.max(20 - Number(gasEstimate - maxGasCost) / 10000, 0)
        score += gasCostScore
      } catch {
        // If gas estimation fails, give neutral score
        score += 10
      }
    } else {
      score += 15 // Neutral score if no gas cost limit
    }
    
    // Pool health score (0-10 points)
    const isHealthy = pool.memberCount > 10 && (pool.transactions?.length || 0) > 0
    score += isHealthy ? 10 : 0
    
    return score
  }
  
  private async estimatePoolGasCost(poolId: string): Promise<bigint> {
    const mockUserOp = {
      sender: '0x1234567890123456789012345678901234567890',
      nonce: 0n,
      callData: '0x',
      callGasLimit: 100000n,
      verificationGasLimit: 100000n,
      preVerificationGas: 21000n,
      maxFeePerGas: 1000000000n,
      maxPriorityFeePerGas: 1000000000n,
      signature: '0x'
    }
    
    const estimate = await this.paymaster.getPaymasterStubData({
      userOp: mockUserOp,
      poolId,
      identity: 'dummy'
    })
    
    return estimate.callGasLimit + estimate.verificationGasLimit + 
           estimate.paymasterVerificationGasLimit + estimate.paymasterPostOpGasLimit
  }
}

// Usage
const poolManager = new AdvancedPoolManager(84532)

const recommendation = await poolManager.selectOptimalPool({
  minAnonymitySet: 50,
  maxGasCost: 500000n,
  excludePools: ['1', '2'], // Recently used pools
  preferredActivity: 'medium'
})

console.log('Recommended pool:', recommendation.selected.poolId)
console.log('Score:', recommendation.analysis.averageScore)
```

## Proof Generation Optimization

### Web Worker Implementation

```typescript
// proof-worker.ts
import { generateProof } from '@semaphore-protocol/proof'
import { Group } from '@semaphore-protocol/group'
import { Identity } from '@semaphore-protocol/identity'

interface ProofWorkerMessage {
  id: string
  type: 'generateProof'
  params: {
    identity: string
    groupMembers: string[]
    message: string
    scope: string
  }
}

self.onmessage = async function(event: MessageEvent<ProofWorkerMessage>) {
  const { id, type, params } = event.data
  
  try {
    if (type === 'generateProof') {
      // Create group from members
      const group = new Group()
      params.groupMembers.forEach(member => group.addMember(member))
      
      // Import identity
      const identity = Identity.import(params.identity)
      
      // Generate proof
      const proof = await generateProof(identity, group, params.message, params.scope)
      
      self.postMessage({
        id,
        type: 'success',
        result: proof
      })
    }
  } catch (error) {
    self.postMessage({
      id,
      type: 'error',
      error: error instanceof Error ? error.message : 'Unknown error'
    })
  }
}
```

```typescript
// proof-worker-manager.ts
class ProofWorkerManager {
  private workers: Worker[] = []
  private pendingTasks = new Map<string, {
    resolve: (value: any) => void
    reject: (error: any) => void
  }>()
  
  constructor(workerCount = navigator.hardwareConcurrency || 2) {
    for (let i = 0; i < workerCount; i++) {
      const worker = new Worker('/proof-worker.js')
      worker.onmessage = this.handleWorkerMessage.bind(this)
      this.workers.push(worker)
    }
  }
  
  async generateProof(params: {
    identity: string
    groupMembers: string[]
    message: string
    scope: string
  }): Promise<any> {
    const id = crypto.randomUUID()
    
    return new Promise((resolve, reject) => {
      this.pendingTasks.set(id, { resolve, reject })
      
      // Find available worker or queue
      const availableWorker = this.workers.find(w => !(w as any).busy)
      
      if (availableWorker) {
        (availableWorker as any).busy = true
        availableWorker.postMessage({
          id,
          type: 'generateProof',
          params
        })
      } else {
        // Queue task (implement queue logic)
        setTimeout(() => this.generateProof(params).then(resolve).catch(reject), 100)
      }
    })
  }
  
  private handleWorkerMessage(event: MessageEvent) {
    const { id, type, result, error } = event.data
    const task = this.pendingTasks.get(id)
    
    if (task) {
      this.pendingTasks.delete(id)
      
      // Mark worker as available
      const worker = event.target as Worker
      ;(worker as any).busy = false
      
      if (type === 'success') {
        task.resolve(result)
      } else {
        task.reject(new Error(error))
      }
    }
  }
  
  terminate() {
    this.workers.forEach(worker => worker.terminate())
    this.workers = []
    this.pendingTasks.clear()
  }
}

// Usage
const proofManager = new ProofWorkerManager()

export async function generateProofAsync(params: any) {
  return proofManager.generateProof(params)
}
```

## Transaction Batching

### Batch Transaction Manager

```typescript
class BatchTransactionManager {
  private pendingTransactions: Array<{
    userOp: any
    poolId: string
    identity: string
    resolve: (value: any) => void
    reject: (error: any) => void
  }> = []
  
  private batchSize = 3
  private batchTimeout = 5000 // 5 seconds
  private batchTimer?: NodeJS.Timeout
  
  constructor(
    private paymaster: PrepaidGasPaymaster,
    private smartAccount: any
  ) {}
  
  async submitTransaction(userOp: any, poolId: string, identity: string): Promise<any> {
    return new Promise((resolve, reject) => {
      this.pendingTransactions.push({
        userOp,
        poolId,
        identity,
        resolve,
        reject
      })
      
      // Start batch timer if not already running
      if (!this.batchTimer) {
        this.batchTimer = setTimeout(() => this.processBatch(), this.batchTimeout)
      }
      
      // Process immediately if batch is full
      if (this.pendingTransactions.length >= this.batchSize) {
        this.processBatch()
      }
    })
  }
  
  private async processBatch() {
    if (this.batchTimer) {
      clearTimeout(this.batchTimer)
      this.batchTimer = undefined
    }
    
    if (this.pendingTransactions.length === 0) return
    
    const batch = this.pendingTransactions.splice(0, this.batchSize)
    
    try {
      // Generate proofs in parallel
      const proofPromises = batch.map(async tx => {
        const paymasterData = await this.paymaster.getPaymasterData({
          userOp: tx.userOp,
          poolId: tx.poolId,
          identity: tx.identity
        })
        
        // Update user operation
        Object.assign(tx.userOp, paymasterData)
        
        return tx
      })
      
      const completedTxs = await Promise.all(proofPromises)
      
      // Submit transactions in sequence with delays
      for (const tx of completedTxs) {
        try {
          const userOpHash = await this.smartAccount.sendUserOperation(tx.userOp)
          const receipt = await this.smartAccount.waitForUserOperationReceipt({
            hash: userOpHash
          })
          
          tx.resolve({
            userOpHash,
            receipt,
            poolId: tx.poolId
          })
          
          // Add delay between transactions for privacy
          if (tx !== completedTxs[completedTxs.length - 1]) {
            await this.randomDelay(1000, 3000)
          }
        } catch (error) {
          tx.reject(error)
        }
      }
    } catch (error) {
      // If batch processing fails, reject all
      batch.forEach(tx => tx.reject(error))
    }
    
    // Process next batch if there are pending transactions
    if (this.pendingTransactions.length > 0) {
      this.batchTimer = setTimeout(() => this.processBatch(), this.batchTimeout)
    }
  }
  
  private async randomDelay(min: number, max: number): Promise<void> {
    const delay = Math.floor(Math.random() * (max - min + 1)) + min
    return new Promise(resolve => setTimeout(resolve, delay))
  }
  
  async flush(): Promise<void> {
    if (this.pendingTransactions.length > 0) {
      await this.processBatch()
    }
  }
}

// Usage
const batchManager = new BatchTransactionManager(paymaster, smartAccount)

// Submit transactions (they will be batched automatically)
const tx1Promise = batchManager.submitTransaction(userOp1, '1', identity1.export())
const tx2Promise = batchManager.submitTransaction(userOp2, '2', identity2.export())
const tx3Promise = batchManager.submitTransaction(userOp3, '1', identity3.export())

// Wait for results
const results = await Promise.all([tx1Promise, tx2Promise, tx3Promise])
```

## Advanced Privacy Patterns

### Identity Rotation Manager

```typescript
class IdentityRotationManager {
  private identities = new Map<string, Identity>()
  private usageCount = new Map<string, number>()
  private maxUsagePerIdentity = 5
  
  constructor(private secureStorage: any) {}
  
  async getIdentityForPool(poolId: string, forceNew = false): Promise<Identity> {
    const identityKey = `pool-${poolId}`
    
    // Check if we need to rotate identity
    if (forceNew || this.shouldRotateIdentity(identityKey)) {
      return this.createNewIdentity(identityKey)
    }
    
    // Get existing identity
    let identity = this.identities.get(identityKey)
    
    if (!identity) {
      // Try to load from secure storage
      const stored = await this.secureStorage.get(identityKey)
      if (stored) {
        identity = Identity.import(stored)
        this.identities.set(identityKey, identity)
      } else {
        identity = await this.createNewIdentity(identityKey)
      }
    }
    
    // Increment usage count
    const currentUsage = this.usageCount.get(identityKey) || 0
    this.usageCount.set(identityKey, currentUsage + 1)
    
    return identity
  }
  
  private shouldRotateIdentity(identityKey: string): boolean {
    const usage = this.usageCount.get(identityKey) || 0
    return usage >= this.maxUsagePerIdentity
  }
  
  private async createNewIdentity(identityKey: string): Promise<Identity> {
    // Archive old identity if it exists
    const oldIdentity = this.identities.get(identityKey)
    if (oldIdentity) {
      await this.archiveIdentity(identityKey, oldIdentity)
    }
    
    // Create new identity
    const newIdentity = new Identity()
    
    // Store securely
    await this.secureStorage.set(identityKey, newIdentity.export())
    
    // Update maps
    this.identities.set(identityKey, newIdentity)
    this.usageCount.set(identityKey, 0)
    
    console.log(`Created new identity for ${identityKey}`)
    
    return newIdentity
  }
  
  private async archiveIdentity(identityKey: string, identity: Identity) {
    const archiveKey = `archive-${identityKey}-${Date.now()}`
    await this.secureStorage.set(archiveKey, identity.export())
    console.log(`Archived identity ${identityKey} to ${archiveKey}`)
  }
  
  getIdentityStats(): Record<string, { usage: number, shouldRotate: boolean }> {
    const stats: Record<string, { usage: number, shouldRotate: boolean }> = {}
    
    this.usageCount.forEach((usage, key) => {
      stats[key] = {
        usage,
        shouldRotate: this.shouldRotateIdentity(key)
      }
    })
    
    return stats
  }
}

// Usage
const identityManager = new IdentityRotationManager(secureStorage)

// Get identity for pool (will rotate if needed)
const identity = await identityManager.getIdentityForPool('1')

// Force rotation for maximum privacy
const newIdentity = await identityManager.getIdentityForPool('1', true)
```

## Performance Monitoring

### Advanced Metrics Collection

```typescript
class PerformanceMonitor {
  private metrics: Array<{
    operation: string
    duration: number
    success: boolean
    poolId?: string
    gasUsed?: string
    timestamp: number
  }> = []
  
  async measureOperation<T>(
    operation: string,
    fn: () => Promise<T>,
    metadata?: any
  ): Promise<T> {
    const startTime = performance.now()
    let success = false
    let result: T
    
    try {
      result = await fn()
      success = true
      return result
    } catch (error) {
      success = false
      throw error
    } finally {
      const duration = performance.now() - startTime
      
      this.metrics.push({
        operation,
        duration,
        success,
        timestamp: Date.now(),
        ...metadata
      })
      
      // Keep only recent metrics
      if (this.metrics.length > 1000) {
        this.metrics = this.metrics.slice(-500)
      }
    }
  }
  
  getMetricsSummary() {
    const summary = {
      totalOperations: this.metrics.length,
      successRate: 0,
      averageDuration: 0,
      operationBreakdown: {} as Record<string, {
        count: number
        averageDuration: number
        successRate: number
      }>
    }
    
    if (this.metrics.length === 0) return summary
    
    const successful = this.metrics.filter(m => m.success)
    summary.successRate = (successful.length / this.metrics.length) * 100
    summary.averageDuration = this.metrics.reduce((sum, m) => sum + m.duration, 0) / this.metrics.length
    
    // Breakdown by operation type
    const operationGroups = this.groupBy(this.metrics, 'operation')
    
    Object.entries(operationGroups).forEach(([operation, metrics]) => {
      const successfulOps = metrics.filter(m => m.success)
      summary.operationBreakdown[operation] = {
        count: metrics.length,
        averageDuration: metrics.reduce((sum, m) => sum + m.duration, 0) / metrics.length,
        successRate: (successfulOps.length / metrics.length) * 100
      }
    })
    
    return summary
  }
  
  private groupBy<T>(array: T[], key: keyof T): Record<string, T[]> {
    return array.reduce((groups, item) => {
      const groupKey = String(item[key])
      groups[groupKey] = groups[groupKey] || []
      groups[groupKey].push(item)
      return groups
    }, {} as Record<string, T[]>)
  }
  
  exportMetrics(): string {
    return JSON.stringify({
      summary: this.getMetricsSummary(),
      rawMetrics: this.metrics
    }, null, 2)
  }
}

// Usage
const monitor = new PerformanceMonitor()

// Measure proof generation
const paymasterData = await monitor.measureOperation(
  'proof-generation',
  () => paymaster.getPaymasterData({ userOp, poolId: '1', identity: identity.export() }),
  { poolId: '1' }
)

// Measure pool queries
const pools = await monitor.measureOperation(
  'pool-query',
  () => subgraph.query().pools().byNetwork('base-sepolia').execute()
)

// Get performance summary
console.log('Performance Summary:', monitor.getMetricsSummary())
```

## Error Recovery and Resilience

### Resilient Transaction Executor

```typescript
class ResilientTransactionExecutor {
  private retryStrategies = {
    'proof-generation': { maxRetries: 2, baseDelay: 1000 },
    'network-error': { maxRetries: 3, baseDelay: 2000 },
    'pool-unavailable': { maxRetries: 1, baseDelay: 5000 }
  }
  
  constructor(
    private paymaster: PrepaidGasPaymaster,
    private poolManager: AdvancedPoolManager,
    private smartAccount: any
  ) {}
  
  async executeTransactionWithRecovery(
    userOp: any,
    options: {
      preferredPoolId?: string
      fallbackPools?: string[]
      maxGasCost?: bigint
      requirePrivacy?: boolean
    } = {}
  ): Promise<any> {
    const attempts = []
    let lastError: any
    
    // Try preferred pool first
    if (options.preferredPoolId) {
      try {
        return await this.attemptTransaction(userOp, options.preferredPoolId)
      } catch (error) {
        attempts.push({ poolId: options.preferredPoolId, error: error.message })
        lastError = error
        
        // If it's a non-recoverable error, fail fast
        if (this.isNonRecoverableError(error)) {
          throw error
        }
      }
    }
    
    // Try fallback pools
    for (const poolId of options.fallbackPools || []) {
      try {
        return await this.attemptTransaction(userOp, poolId)
      } catch (error) {
        attempts.push({ poolId, error: error.message })
        lastError = error
      }
    }
    
    // Find alternative pools automatically
    try {
      const poolRecommendation = await this.poolManager.selectOptimalPool({
        minAnonymitySet: options.requirePrivacy ? 50 : 10,
        maxGasCost: options.maxGasCost,
        excludePools: [
          options.preferredPoolId,
          ...options.fallbackPools || []
        ].filter(Boolean) as string[]
      })
      
      // Try recommended pool
      return await this.attemptTransaction(userOp, poolRecommendation.selected.poolId)
    } catch (error) {
      attempts.push({ poolId: 'auto-selected', error: error.message })
      
      // All recovery attempts failed
      throw new Error(`Transaction failed after trying ${attempts.length} pools. Last error: ${lastError.message}`)
    }
  }
  
  private async attemptTransaction(userOp: any, poolId: string): Promise<any> {
    // Generate paymaster data with retries
    const paymasterData = await this.withRetry(
      () => this.paymaster.getPaymasterData({
        userOp,
        poolId,
        identity: this.getIdentityForPool(poolId)
      }),
      'proof-generation'
    )
    
    // Update user operation
    Object.assign(userOp, paymasterData)
    
    // Submit transaction with retries
    const userOpHash = await this.withRetry(
      () => this.smartAccount.sendUserOperation(userOp),
      'network-error'
    )
    
    // Wait for receipt
    const receipt = await this.smartAccount.waitForUserOperationReceipt({
      hash: userOpHash
    })
    
    return {
      userOpHash,
      receipt,
      poolId,
      gasUsed: receipt.receipt.gasUsed
    }
  }
  
  private async withRetry<T>(
    operation: () => Promise<T>,
    strategyKey: keyof typeof this.retryStrategies
  ): Promise<T> {
    const strategy = this.retryStrategies[strategyKey]
    let lastError: any
    
    for (let attempt = 0; attempt <= strategy.maxRetries; attempt++) {
      try {
        return await operation()
      } catch (error) {
        lastError = error
        
        if (attempt === strategy.maxRetries) {
          throw error
        }
        
        // Wait before retry with exponential backoff
        const delay = strategy.baseDelay * Math.pow(2, attempt)
        await new Promise(resolve => setTimeout(resolve, delay))
      }
    }
    
    throw lastError
  }
  
  private isNonRecoverableError(error: any): boolean {
    // Define errors that shouldn't be retried
    const nonRecoverableMessages = [
      'Invalid user operation',
      'Insufficient funds',
      'Invalid signature',
      'Nonce too low'
    ]
    
    return nonRecoverableMessages.some(msg => 
      error.message.toLowerCase().includes(msg.toLowerCase())
    )
  }
  
  private getIdentityForPool(poolId: string): string {
    // Implementation depends on your identity management strategy
    // This is a simplified version
    const identity = new Identity()
    return identity.export()
  }
}

// Usage
const executor = new ResilientTransactionExecutor(paymaster, poolManager, smartAccount)

const result = await executor.executeTransactionWithRecovery(userOp, {
  preferredPoolId: '1',
  fallbackPools: ['2', '3'],
  maxGasCost: 500000n,
  requirePrivacy: true
})

console.log('Transaction successful:', result.userOpHash)
```

These advanced examples demonstrate sophisticated patterns for production use of the Prepaid Gas SDK, including intelligent pool management, performance optimization, and robust error handling.