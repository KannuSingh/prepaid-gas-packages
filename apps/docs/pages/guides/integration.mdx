# Integration Guide

Production deployment guide for integrating the Prepaid Gas SDK into your application.

## Production Setup

### Environment Configuration

Set up your environment variables:

```bash
# .env.local (Next.js) or .env (Node.js)
NEXT_PUBLIC_CHAIN_ID=84532
NEXT_PUBLIC_SUBGRAPH_URL=https://api.thegraph.com/subgraphs/name/your-subgraph
NEXT_PUBLIC_BUNDLER_URL=https://api.pimlico.io/v2/base-sepolia/rpc?apikey=YOUR_KEY
```

### Client Configuration

```typescript
// lib/paymaster.ts
import { PrepaidGasPaymaster } from '@prepaid-gas/core'
import { SubgraphClient } from '@prepaid-gas/data'

export const paymaster = PrepaidGasPaymaster.createForNetwork(
  parseInt(process.env.NEXT_PUBLIC_CHAIN_ID!)
)

export const subgraphClient = SubgraphClient.createForNetwork(
  parseInt(process.env.NEXT_PUBLIC_CHAIN_ID!)
)
```

## Integration Patterns

### React Hook Pattern

```typescript
// hooks/usePaymaster.ts
import { useMemo } from 'react'
import { PrepaidGasPaymaster } from '@prepaid-gas/core'
import { useChainId } from 'wagmi'

export function usePaymaster() {
  const chainId = useChainId()
  
  return useMemo(
    () => PrepaidGasPaymaster.createForNetwork(chainId),
    [chainId]
  )
}

// hooks/usePoolData.ts
import { useQuery } from '@tanstack/react-query'
import { SubgraphClient } from '@prepaid-gas/data'

export function usePoolData(chainId: number) {
  const client = useMemo(
    () => SubgraphClient.createForNetwork(chainId),
    [chainId]
  )
  
  return useQuery({
    queryKey: ['pools', chainId],
    queryFn: () => client.query()
      .pools()
      .byNetwork('base-sepolia')
      .withMembers(100)
      .executeAndSerialize(),
    staleTime: 5 * 60 * 1000, // 5 minutes
  })
}
```

### Context Provider Pattern

```typescript
// context/PaymasterProvider.tsx
import { createContext, useContext, ReactNode } from 'react'
import { PrepaidGasPaymaster } from '@prepaid-gas/core'
import { SubgraphClient } from '@prepaid-gas/data'

interface PaymasterContextType {
  paymaster: PrepaidGasPaymaster
  subgraphClient: SubgraphClient
  chainId: number
}

const PaymasterContext = createContext<PaymasterContextType | null>(null)

export function PaymasterProvider({ 
  children, 
  chainId 
}: { 
  children: ReactNode
  chainId: number 
}) {
  const paymaster = useMemo(
    () => PrepaidGasPaymaster.createForNetwork(chainId),
    [chainId]
  )
  
  const subgraphClient = useMemo(
    () => SubgraphClient.createForNetwork(chainId),
    [chainId]
  )
  
  return (
    <PaymasterContext.Provider value={{ paymaster, subgraphClient, chainId }}>
      {children}
    </PaymasterContext.Provider>
  )
}

export function usePaymasterContext() {
  const context = useContext(PaymasterContext)
  if (!context) {
    throw new Error('usePaymasterContext must be used within PaymasterProvider')
  }
  return context
}
```

## Error Handling Strategy

### Comprehensive Error Handling

```typescript
// utils/error-handling.ts
import { 
  ValidationError, 
  PaymasterError, 
  SubgraphError 
} from '@prepaid-gas/core'

export interface ErrorResult {
  type: 'validation' | 'paymaster' | 'subgraph' | 'network' | 'unknown'
  message: string
  field?: string
  code?: string
  retryable: boolean
}

export function handlePaymasterError(error: unknown): ErrorResult {
  if (error instanceof ValidationError) {
    return {
      type: 'validation',
      message: error.message,
      field: error.field,
      retryable: false
    }
  }
  
  if (error instanceof PaymasterError) {
    return {
      type: 'paymaster',
      message: error.message,
      code: error.code,
      retryable: error.code === 'NETWORK_ERROR'
    }
  }
  
  if (error instanceof SubgraphError) {
    return {
      type: 'subgraph',
      message: error.message,
      retryable: true
    }
  }
  
  if (error instanceof Error && error.message.includes('fetch')) {
    return {
      type: 'network',
      message: 'Network connection failed',
      retryable: true
    }
  }
  
  return {
    type: 'unknown',
    message: error instanceof Error ? error.message : 'Unknown error',
    retryable: false
  }
}

// React hook for error handling
export function useErrorHandler() {
  const [error, setError] = useState<ErrorResult | null>(null)
  
  const handleError = useCallback((err: unknown) => {
    const errorResult = handlePaymasterError(err)
    setError(errorResult)
    
    // Log to monitoring service
    if (errorResult.type === 'unknown') {
      console.error('Unexpected error:', err)
      // Send to Sentry, DataDog, etc.
    }
  }, [])
  
  const clearError = useCallback(() => setError(null), [])
  
  return { error, handleError, clearError }
}
```

### Retry Logic

```typescript
// utils/retry.ts
export async function withRetry<T>(
  operation: () => Promise<T>,
  maxRetries = 3,
  delay = 1000
): Promise<T> {
  let lastError: unknown
  
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await operation()
    } catch (error) {
      lastError = error
      
      const errorResult = handlePaymasterError(error)
      
      if (!errorResult.retryable || attempt === maxRetries) {
        throw error
      }
      
      // Exponential backoff
      await new Promise(resolve => 
        setTimeout(resolve, delay * Math.pow(2, attempt))
      )
    }
  }
  
  throw lastError
}

// Usage
const pools = await withRetry(() => 
  subgraphClient.query()
    .pools()
    .byNetwork('base-sepolia')
    .execute()
)
```

## Performance Optimization

### Caching Strategy

```typescript
// utils/cache.ts
interface CacheEntry<T> {
  data: T
  timestamp: number
  ttl: number
}

class SimpleCache<T> {
  private cache = new Map<string, CacheEntry<T>>()
  
  set(key: string, data: T, ttl = 5 * 60 * 1000) { // 5 minutes default
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl
    })
  }
  
  get(key: string): T | null {
    const entry = this.cache.get(key)
    
    if (!entry) return null
    
    if (Date.now() - entry.timestamp > entry.ttl) {
      this.cache.delete(key)
      return null
    }
    
    return entry.data
  }
  
  clear() {
    this.cache.clear()
  }
}

// Cached subgraph client
export class CachedSubgraphClient {
  private client: SubgraphClient
  private cache = new SimpleCache<any>()
  
  constructor(chainId: number) {
    this.client = SubgraphClient.createForNetwork(chainId)
  }
  
  async getPools(network: string, useCache = true) {
    const cacheKey = `pools-${network}`
    
    if (useCache) {
      const cached = this.cache.get(cacheKey)
      if (cached) return cached
    }
    
    const pools = await this.client.query()
      .pools()
      .byNetwork(network as any)
      .withMembers(100)
      .executeAndSerialize()
    
    this.cache.set(cacheKey, pools, 2 * 60 * 1000) // 2 minutes for pools
    
    return pools
  }
}
```

### Proof Generation Optimization

```typescript
// utils/proof-optimization.ts
import { Identity } from '@semaphore-protocol/identity'

// Web Worker for proof generation (non-blocking)
export class ProofWorkerPool {
  private workers: Worker[] = []
  private queue: Array<{
    resolve: (value: any) => void
    reject: (error: any) => void
    params: any
  }> = []
  
  constructor(workerCount = 2) {
    for (let i = 0; i < workerCount; i++) {
      const worker = new Worker('/proof-worker.js')
      worker.onmessage = this.handleWorkerMessage.bind(this)
      this.workers.push(worker)
    }
  }
  
  async generateProof(params: any): Promise<any> {
    return new Promise((resolve, reject) => {
      this.queue.push({ resolve, reject, params })
      this.processQueue()
    })
  }
  
  private processQueue() {
    if (this.queue.length === 0) return
    
    const availableWorker = this.workers.find(w => !w.busy)
    if (!availableWorker) return
    
    const { resolve, reject, params } = this.queue.shift()!
    availableWorker.busy = true
    availableWorker.currentResolve = resolve
    availableWorker.currentReject = reject
    
    availableWorker.postMessage(params)
  }
  
  private handleWorkerMessage(event: MessageEvent) {
    const worker = event.target as Worker & { 
      busy?: boolean
      currentResolve?: (value: any) => void
      currentReject?: (error: any) => void
    }
    
    worker.busy = false
    
    if (event.data.error) {
      worker.currentReject?.(new Error(event.data.error))
    } else {
      worker.currentResolve?.(event.data.result)
    }
    
    this.processQueue() // Process next in queue
  }
}

// Usage in component
const proofWorkerPool = new ProofWorkerPool()

export function useOptimizedProofGeneration() {
  const generateProof = useCallback(async (params: any) => {
    return proofWorkerPool.generateProof(params)
  }, [])
  
  return { generateProof }
}
```

## Security Best Practices

### Identity Management

```typescript
// utils/secure-storage.ts
export class SecureIdentityStorage {
  private static readonly STORAGE_KEY = 'prepaid-gas-identity'
  
  static async store(identity: Identity): Promise<void> {
    try {
      // Use secure storage in production
      if (typeof window !== 'undefined' && window.crypto) {
        // Browser: Use IndexedDB with encryption
        await this.storeInIndexedDB(identity.export())
      } else {
        // Node.js: Use encrypted file storage
        await this.storeInFile(identity.export())
      }
    } catch (error) {
      console.error('Failed to store identity securely:', error)
      throw new Error('Identity storage failed')
    }
  }
  
  static async retrieve(): Promise<Identity | null> {
    try {
      let exportedIdentity: string | null = null
      
      if (typeof window !== 'undefined') {
        exportedIdentity = await this.retrieveFromIndexedDB()
      } else {
        exportedIdentity = await this.retrieveFromFile()
      }
      
      return exportedIdentity ? Identity.import(exportedIdentity) : null
    } catch (error) {
      console.error('Failed to retrieve identity:', error)
      return null
    }
  }
  
  private static async storeInIndexedDB(exported: string): Promise<void> {
    // Implementation depends on your encryption strategy
    // Consider using libraries like crypto-js for encryption
  }
  
  private static async retrieveFromIndexedDB(): Promise<string | null> {
    // Implementation depends on your encryption strategy
    return null
  }
  
  private static async storeInFile(exported: string): Promise<void> {
    // Server-side secure file storage
  }
  
  private static async retrieveFromFile(): Promise<string | null> {
    // Server-side secure file retrieval
    return null
  }
}
```

### Input Validation

```typescript
// utils/validation.ts
import { validatePoolId } from '@prepaid-gas/core'

export function validateUserInputs(params: {
  poolId: string
  userOp: any
  identity: string
}) {
  // Validate pool ID
  try {
    validatePoolId(params.poolId)
  } catch (error) {
    throw new Error(`Invalid pool ID: ${error.message}`)
  }
  
  // Validate user operation structure
  if (!params.userOp.sender || !params.userOp.callData) {
    throw new Error('Invalid user operation')
  }
  
  // Validate identity format
  if (!params.identity || params.identity.length === 0) {
    throw new Error('Identity is required')
  }
  
  try {
    // Attempt to decode base64
    atob(params.identity)
  } catch {
    throw new Error('Invalid identity format')
  }
}
```

## Monitoring and Analytics

### Usage Tracking

```typescript
// utils/analytics.ts
interface PaymasterMetrics {
  proofGenerationTime: number
  poolId: string
  gasEstimate: string
  success: boolean
  errorType?: string
}

export class PaymasterAnalytics {
  static trackProofGeneration(metrics: PaymasterMetrics) {
    // Send to your analytics service
    if (typeof window !== 'undefined') {
      // Client-side tracking (e.g., Google Analytics, Mixpanel)
      gtag('event', 'proof_generation', {
        duration: metrics.proofGenerationTime,
        pool_id: metrics.poolId,
        success: metrics.success
      })
    } else {
      // Server-side tracking
      console.log('Proof generation metrics:', metrics)
    }
  }
  
  static trackError(error: ErrorResult, context: any) {
    // Error tracking (e.g., Sentry)
    console.error('Paymaster error:', { error, context })
  }
}

// Usage in paymaster operations
export async function trackableProofGeneration(params: any) {
  const startTime = Date.now()
  
  try {
    const result = await paymaster.getPaymasterData(params)
    
    PaymasterAnalytics.trackProofGeneration({
      proofGenerationTime: Date.now() - startTime,
      poolId: params.poolId,
      gasEstimate: result.callGasLimit.toString(),
      success: true
    })
    
    return result
  } catch (error) {
    const errorResult = handlePaymasterError(error)
    
    PaymasterAnalytics.trackProofGeneration({
      proofGenerationTime: Date.now() - startTime,
      poolId: params.poolId,
      gasEstimate: '0',
      success: false,
      errorType: errorResult.type
    })
    
    PaymasterAnalytics.trackError(errorResult, params)
    
    throw error
  }
}
```

## Testing Strategy

### Unit Testing

```typescript
// __tests__/paymaster.test.ts
import { PrepaidGasPaymaster } from '@prepaid-gas/core'
import { mockSubgraphResponse } from './mocks'

describe('PaymasterIntegration', () => {
  let paymaster: PrepaidGasPaymaster
  
  beforeEach(() => {
    paymaster = PrepaidGasPaymaster.createForNetwork(84532)
    
    // Mock subgraph responses
    jest.spyOn(global, 'fetch').mockImplementation(mockSubgraphResponse)
  })
  
  it('should generate stub data for gas estimation', async () => {
    const result = await paymaster.getPaymasterStubData({
      userOp: mockUserOp,
      poolId: '1',
      identity: mockIdentity
    })
    
    expect(result.isFinal).toBe(false)
    expect(result.callGasLimit).toBeGreaterThan(0n)
  })
  
  it('should handle validation errors gracefully', async () => {
    await expect(
      paymaster.getPaymasterData({
        userOp: mockUserOp,
        poolId: 'invalid',
        identity: mockIdentity
      })
    ).rejects.toThrow(ValidationError)
  })
})
```

### Integration Testing

```typescript
// __tests__/integration.test.ts
import { setupTestEnvironment, cleanupTestEnvironment } from './test-utils'

describe('End-to-End Integration', () => {
  beforeEach(async () => {
    await setupTestEnvironment()
  })
  
  afterEach(async () => {
    await cleanupTestEnvironment()
  })
  
  it('should complete full paymaster flow', async () => {
    // 1. Query available pools
    const pools = await subgraphClient.query()
      .pools()
      .byNetwork('base-sepolia')
      .execute()
    
    expect(pools).toHaveLength(1)
    
    // 2. Generate proof and paymaster data
    const result = await paymaster.getPaymasterData({
      userOp: mockUserOp,
      poolId: pools[0].poolId,
      identity: testIdentity
    })
    
    expect(result.isFinal).toBe(true)
    expect(result.paymasterData).toHaveLength(962) // 0x + 960 hex chars
  })
})
```

## Deployment Checklist

### Pre-deployment

- [ ] Environment variables configured
- [ ] Error handling implemented
- [ ] Caching strategy in place
- [ ] Security review completed
- [ ] Testing coverage adequate
- [ ] Monitoring setup configured

### Production Configuration

- [ ] Use production subgraph endpoints
- [ ] Configure proper RPC endpoints
- [ ] Set up error reporting (Sentry, etc.)
- [ ] Enable analytics tracking
- [ ] Configure rate limiting
- [ ] Set up health checks

### Post-deployment

- [ ] Monitor error rates
- [ ] Track proof generation times
- [ ] Monitor pool usage patterns
- [ ] Set up alerts for failures
- [ ] Regular security audits