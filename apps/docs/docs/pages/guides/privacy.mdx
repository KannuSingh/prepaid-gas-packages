# Privacy Best Practices

Guidelines for maximizing privacy when using PrepaidGas paymasters.

## Understanding Privacy Model

### Pool-Based Anonymity
- **Anonymity set**: Hide among all members of the same paymaster pool
- **Linkability**: Transactions within same paymaster are linkable via nullifiers
- **Cross-pool privacy**: Use different identities for different paymasters

### Privacy Levels by Paymaster Type

#### OneTimeUse - Maximum Privacy
```typescript
// Each transaction is completely unlinkable
// Fresh nullifier required for each transaction
const paymaster = 'OneTimeUse' // Best for sensitive operations
```

#### GasLimited - Moderate Privacy  
```typescript
// Transactions linkable within same nullifier
// Multiple txs from one deposit create transaction graph
const paymaster = 'GasLimited' // Good for related operations
```

#### CacheEnabled - Efficiency Over Privacy
```typescript
// Most linkable due to nullifier caching
// 2-nullifier system creates patterns
const paymaster = 'CacheEnabled' // Use for non-sensitive bulk operations
```

## Identity Management

### 1. Identity Isolation Strategy

```typescript
// Different identities for different use cases
const createIsolatedIdentity = (purpose: string) => {
  const identity = new Identity()
  const key = `identity-${purpose}`
  
  // Store separately for each purpose
  localStorage.setItem(key, identity.export())
  return identity
}

// Examples
const tradingIdentity = createIsolatedIdentity('trading')
const governanceIdentity = createIsolatedIdentity('governance') 
const donationIdentity = createIsolatedIdentity('donations')
```

### 2. Identity Rotation

```typescript
// Rotate identities periodically for OneTimeUse
const rotateIdentity = async (paymasterAddress: string) => {
  // Clear old identity
  localStorage.removeItem('current-identity')
  
  // Create new identity
  const newIdentity = new Identity()
  localStorage.setItem('current-identity', newIdentity.export())
  
  // Must deposit with new identity before use
  await depositToPool(paymasterAddress, newIdentity.commitment)
  
  return newIdentity
}
```

### 3. Secure Storage

```typescript
// Encrypt identity storage (optional)
import CryptoJS from 'crypto-js'

const storeIdentitySecurely = (identity: Identity, password: string) => {
  const exported = identity.export()
  const encrypted = CryptoJS.AES.encrypt(exported, password).toString()
  localStorage.setItem('encrypted-identity', encrypted)
}

const loadIdentitySecurely = (password: string): Identity | null => {
  try {
    const encrypted = localStorage.getItem('encrypted-identity')
    if (!encrypted) return null
    
    const decrypted = CryptoJS.AES.decrypt(encrypted, password).toString(CryptoJS.enc.Utf8)
    return Identity.import(decrypted)
  } catch {
    return null
  }
}
```

## Paymaster Selection Strategy

### 1. Privacy-First Selection

```typescript
const selectPaymasterByPrivacyNeed = (operation: string) => {
  const privacyNeeds = {
    'sensitive-payment': 'OneTimeUse',
    'anonymous-donation': 'OneTimeUse', 
    'regular-trading': 'GasLimited',
    'gaming-actions': 'CacheEnabled',
    'bulk-operations': 'CacheEnabled'
  } as const
  
  return privacyNeeds[operation] || 'OneTimeUse'
}

// Usage
const paymasterType = selectPaymasterByPrivacyNeed('sensitive-payment')
```

### 2. Pool Size Consideration

```typescript
// Choose pools with more members for better anonymity
const selectLargestPool = async (paymasterType: string) => {
  const client = SubgraphClient.createForNetwork(84532)
  
  const paymasters = await client.query()
    .paymasters()
    .byContractType(paymasterType)
    .orderByMembers('desc') // Largest pools first
    .limit(5)
    .execute()
  
  // Choose from top pools randomly
  const randomIndex = Math.floor(Math.random() * Math.min(paymasters.length, 3))
  return paymasters[randomIndex]
}
```

## Transaction Patterns

### 1. Timing Anonymity

```typescript
// Add random delays to break timing analysis
const executeWithRandomDelay = async (transaction: () => Promise<any>) => {
  // Random delay between 1-10 seconds
  const delay = Math.random() * 9000 + 1000
  await new Promise(resolve => setTimeout(resolve, delay))
  
  return transaction()
}
```

### 2. Amount Obfuscation

```typescript
// Use common amounts to blend in
const COMMON_AMOUNTS = [
  '0.001', '0.01', '0.1', '1.0', '10.0'
] // ETH amounts

const selectCommonAmount = (targetAmount: string) => {
  // Find closest common amount
  const target = parseFloat(targetAmount)
  return COMMON_AMOUNTS.reduce((prev, curr) => 
    Math.abs(parseFloat(curr) - target) < Math.abs(parseFloat(prev) - target) 
      ? curr : prev
  )
}
```

### 3. Batch Transactions Carefully

```typescript
// Avoid patterns in batched transactions
const executeBatchWithVariation = async (transactions: Array<() => Promise<any>>) => {
  const shuffled = [...transactions].sort(() => Math.random() - 0.5)
  
  for (const tx of shuffled) {
    await executeWithRandomDelay(tx)
  }
}
```

## Network-Level Privacy

### 1. RPC Endpoint Diversity

```typescript
// Rotate RPC endpoints to avoid correlation
const RPC_ENDPOINTS = [
  'https://mainnet.base.org',
  'https://base-mainnet.g.alchemy.com/v2/your-key',
  'https://1rpc.io/base'
]

const getRandomRPC = () => {
  return RPC_ENDPOINTS[Math.floor(Math.random() * RPC_ENDPOINTS.length)]
}

// Use different endpoints for different operations
const createClientWithRandomRPC = () => {
  return createPublicClient({
    chain: base,
    transport: http(getRandomRPC())
  })
}
```

### 2. Tor/VPN Considerations

```typescript
// Check if using privacy network
const isPrivacyNetwork = () => {
  // Basic check for Tor (example)
  return window.location.hostname.endsWith('.onion')
}

const adjustForPrivacyNetwork = () => {
  if (isPrivacyNetwork()) {
    // Longer timeouts for Tor
    return { timeout: 30000 }
  }
  return { timeout: 10000 }
}
```

## Metadata Protection

### 1. Transaction Metadata

```typescript
// Minimize identifying information in transactions
const sanitizeTransactionData = (data: any) => {
  // Remove or obfuscate identifying fields
  const sanitized = { ...data }
  delete sanitized.deviceId
  delete sanitized.userAgent
  delete sanitized.timestamp // Use block timestamp instead
  
  return sanitized
}
```

### 2. Local Storage Hygiene

```typescript
// Clear sensitive data periodically
const clearSensitiveData = () => {
  const sensitiveKeys = [
    'burner-private-key',
    'recent-transactions',
    'gas-estimates'
  ]
  
  sensitiveKeys.forEach(key => {
    localStorage.removeItem(key)
  })
}

// Set up periodic cleanup
setInterval(clearSensitiveData, 24 * 60 * 60 * 1000) // Daily
```

## Advanced Privacy Techniques

### 1. Identity Pools

```typescript
// Maintain pool of identities for rotation
class IdentityPool {
  private identities: Identity[] = []
  private used: Set<string> = new Set()
  
  constructor(poolSize: number = 5) {
    for (let i = 0; i < poolSize; i++) {
      this.identities.push(new Identity())
    }
  }
  
  getUnusedIdentity(): Identity | null {
    const unused = this.identities.find(id => 
      !this.used.has(id.commitment.toString())
    )
    
    if (unused) {
      this.used.add(unused.commitment.toString())
      return unused
    }
    
    return null
  }
  
  resetPool() {
    this.used.clear()
  }
}
```

### 2. Decoy Transactions

```typescript
// Generate decoy transactions for anonymity
const generateDecoyTransaction = async (smartAccountClient: any) => {
  // Low-value transaction to create noise
  const decoy = await smartAccountClient.writeContract({
    address: '0x0000000000000000000000000000000000000000',
    abi: [],
    functionName: 'transfer',
    args: [smartAccountClient.account.address, 1n] // 1 wei to self
  })
  
  return decoy
}
```

## Privacy Checklist

### Before Transaction
- [ ] Choose appropriate paymaster type for privacy needs
- [ ] Verify anonymity set size (pool membership)  
- [ ] Use dedicated identity for sensitive operations
- [ ] Check RPC endpoint diversity
- [ ] Consider timing patterns

### During Transaction
- [ ] Use common transaction amounts when possible
- [ ] Add random delays between related transactions
- [ ] Avoid identifying transaction data
- [ ] Monitor for correlation patterns

### After Transaction
- [ ] Clear temporary data
- [ ] Rotate identities if needed
- [ ] Analyze transaction graph for leaks
- [ ] Update privacy strategies based on usage

## Privacy Trade-offs

### Performance vs Privacy
```typescript
// Higher privacy = Higher costs
const privacyLevels = {
  maximum: { paymaster: 'OneTimeUse', cost: 'High', privacy: 'Maximum' },
  balanced: { paymaster: 'GasLimited', cost: 'Medium', privacy: 'Good' },
  efficient: { paymaster: 'CacheEnabled', cost: 'Low', privacy: 'Basic' }
}
```

### Usability vs Privacy
- **Maximum privacy**: Requires frequent identity rotation
- **Balanced approach**: Moderate complexity with good privacy
- **Efficiency focus**: Simple but more linkable

Choose based on your specific threat model and use case requirements.