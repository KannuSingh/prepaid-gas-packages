# Integration Guide

Complete step-by-step guide to integrate PrepaidGas paymasters into your dApp.

## Overview

You'll learn to:
1. Set up the paymaster client
2. Manage Semaphore identities
3. Create smart account with paymaster
4. Execute transactions with privacy

## Step 1: Install Dependencies

```bash
npm install @prepaid-gas/core @prepaid-gas/data
npm install @semaphore-protocol/identity @semaphore-protocol/group
npm install permissionless viem
```

## Step 2: Environment Setup

Create environment variables:

```bash
# .env.local
NEXT_PUBLIC_CHAIN_ID=84532
NEXT_PUBLIC_BUNDLER_URL=http://localhost:4337
NEXT_PUBLIC_SUBGRAPH_URL=https://api.studio.thegraph.com/query/...
```

## Step 3: Create Paymaster Client

```typescript
// lib/paymaster.ts
import { PrepaidGasPaymaster } from '@prepaid-gas/core'

export const createPaymasterClient = () => {
  const chainId = parseInt(process.env.NEXT_PUBLIC_CHAIN_ID!)
  
  return PrepaidGasPaymaster.createForNetwork(chainId, {
    subgraphUrl: process.env.NEXT_PUBLIC_SUBGRAPH_URL
  })
}
```

## Step 4: Identity Management

### Create Identity Storage Hook

```typescript
// hooks/use-identity-storage.ts
import { useState, useEffect } from 'react'
import { Identity } from '@semaphore-protocol/identity'

export function useIdentityStorage() {
  const [identity, setIdentity] = useState<Identity | null>(null)
  const [isLoading, setIsLoading] = useState(true)

  useEffect(() => {
    loadIdentity()
  }, [])

  const loadIdentity = async () => {
    try {
      const stored = localStorage.getItem('semaphore-identity')
      if (stored) {
        const identity = Identity.import(stored)
        setIdentity(identity)
      }
    } catch (error) {
      console.error('Failed to load identity:', error)
    } finally {
      setIsLoading(false)
    }
  }

  const createIdentity = () => {
    const newIdentity = new Identity()
    const exported = newIdentity.export()
    
    localStorage.setItem('semaphore-identity', exported)
    setIdentity(newIdentity)
    
    return newIdentity
  }

  const clearIdentity = () => {
    localStorage.removeItem('semaphore-identity')
    setIdentity(null)
  }

  return {
    identity,
    isLoading,
    createIdentity,
    clearIdentity
  }
}
```

## Step 5: Paymaster Context

### Create Paymaster Configuration Type

```typescript
// types/paymaster.ts
export interface PaymasterConfig {
  identity: string           // Exported Semaphore identity
  address: string           // Paymaster contract address
  paymasterContext: string  // Encoded context for transactions
}
```

### Create Paymaster Context

```typescript
// context/PaymasterContext.tsx
'use client'

import React, { createContext, useContext, ReactNode } from 'react'
import { Identity } from '@semaphore-protocol/identity'
import { PaymasterConfig } from '@/types/paymaster'
import { useIdentityStorage } from '@/hooks/use-identity-storage'

interface PaymasterContextType {
  // State
  identity: Identity | null
  paymasterConfig: PaymasterConfig | null
  isConfigured: boolean
  
  // Actions
  setPaymasterConfig: (config: PaymasterConfig) => void
  clearPaymasterConfig: () => void
  createIdentity: () => Identity
}

const PaymasterContext = createContext<PaymasterContextType | undefined>(undefined)

export function PaymasterProvider({ children }: { children: ReactNode }) {
  const { identity, createIdentity, clearIdentity } = useIdentityStorage()
  const [paymasterConfig, setConfig] = useState<PaymasterConfig | null>(null)

  const setPaymasterConfig = (config: PaymasterConfig) => {
    setConfig(config)
    // Persist to localStorage
    localStorage.setItem('paymaster-config', JSON.stringify(config))
  }

  const clearPaymasterConfig = () => {
    setConfig(null)
    localStorage.removeItem('paymaster-config')
    clearIdentity()
  }

  const isConfigured = Boolean(identity && paymasterConfig)

  return (
    <PaymasterContext.Provider value={{
      identity,
      paymasterConfig,
      isConfigured,
      setPaymasterConfig,
      clearPaymasterConfig,
      createIdentity
    }}>
      {children}
    </PaymasterContext.Provider>
  )
}

export const usePaymaster = () => {
  const context = useContext(PaymasterContext)
  if (!context) {
    throw new Error('usePaymaster must be used within PaymasterProvider')
  }
  return context
}
```

## Step 6: Smart Account Integration

### Create Smart Account Hook

```typescript
// hooks/use-smart-account.ts
import { useState, useEffect } from 'react'
import { createSmartAccountClient } from 'permissionless'
import { toSimpleSmartAccount } from 'permissionless/accounts'
import { createPublicClient, http, generatePrivateKey, privateKeyToAccount } from 'viem'
import { baseSepolia } from 'viem/chains'
import { entryPoint07Address } from 'viem/account-abstraction'
import { createPaymasterClient } from '@/lib/paymaster'
import { PaymasterConfig } from '@/types/paymaster'

export function useSmartAccount(paymasterConfig: PaymasterConfig | null) {
  const [smartAccountClient, setSmartAccountClient] = useState(null)
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    if (paymasterConfig && !smartAccountClient) {
      createSmartAccount()
    }
  }, [paymasterConfig])

  const createSmartAccount = async () => {
    if (!paymasterConfig) return
    
    setIsLoading(true)
    setError(null)

    try {
      // Create or load burner signer
      let privateKey = localStorage.getItem('burner-key')
      if (!privateKey) {
        privateKey = generatePrivateKey()
        localStorage.setItem('burner-key', privateKey)
      }

      const publicClient = createPublicClient({
        chain: baseSepolia,
        transport: http()
      })

      // Create simple smart account
      const smartAccount = await toSimpleSmartAccount({
        owner: privateKeyToAccount(privateKey),
        client: publicClient,
        entryPoint: {
          address: entryPoint07Address,
          version: '0.7'
        }
      })

      // Create paymaster client
      const paymasterClient = createPaymasterClient()

      // Create smart account client with paymaster
      const client = createSmartAccountClient({
        client: publicClient,
        account: smartAccount,
        bundlerTransport: http(process.env.NEXT_PUBLIC_BUNDLER_URL),
        paymaster: {
          getPaymasterStubData: paymasterClient.getPaymasterStubData.bind(paymasterClient),
          getPaymasterData: paymasterClient.getPaymasterData.bind(paymasterClient)
        },
        paymasterContext: paymasterConfig.paymasterContext
      })

      setSmartAccountClient(client)
    } catch (err) {
      setError((err as Error).message)
    } finally {
      setIsLoading(false)
    }
  }

  return {
    smartAccountClient,
    isLoading,
    error,
    accountAddress: smartAccountClient?.account?.address
  }
}
```

## Step 7: Paymaster Configuration

### Create Configuration Component  

```typescript
// components/PaymasterSetup.tsx
'use client'

import { useState } from 'react'
import { encodePaymasterContext } from '@prepaid-gas/core'
import { usePaymaster } from '@/context/PaymasterContext'

const PAYMASTER_ADDRESSES = {
  OneTimeUse: '0x4DACA5b0a5d10853F84bB400C5232E4605bc14A0',
  GasLimited: '0xDEc68496A556CeE996894ac2FDc9E43F39938e62',
  CacheEnabled: '0xfFE794611e59A987D8f13585248414d40a02Bb58'
}

export function PaymasterSetup() {
  const { identity, createIdentity, setPaymasterConfig } = usePaymaster()
  const [selectedType, setSelectedType] = useState<keyof typeof PAYMASTER_ADDRESSES>('OneTimeUse')
  const [isLoading, setIsLoading] = useState(false)

  const handleSetup = async () => {
    setIsLoading(true)

    try {
      // Create identity if needed
      const userIdentity = identity || createIdentity()
      
      // Get paymaster address
      const paymasterAddress = PAYMASTER_ADDRESSES[selectedType]
      
      // Encode context
      const context = encodePaymasterContext(
        paymasterAddress,
        userIdentity.export()
      )

      // Save configuration
      setPaymasterConfig({
        identity: userIdentity.export(),
        address: paymasterAddress,
        paymasterContext: context
      })

    } catch (error) {
      console.error('Setup failed:', error)
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <div className="space-y-4">
      <h3>Paymaster Setup</h3>
      
      <div>
        <label>Paymaster Type:</label>
        <select 
          value={selectedType} 
          onChange={(e) => setSelectedType(e.target.value as keyof typeof PAYMASTER_ADDRESSES)}
        >
          <option value="OneTimeUse">OneTimeUse (Max Privacy)</option>
          <option value="GasLimited">GasLimited (Multi-use)</option>
          <option value="CacheEnabled">CacheEnabled (Optimized)</option>
        </select>
      </div>

      <button 
        onClick={handleSetup}
        disabled={isLoading}
      >
        {isLoading ? 'Setting up...' : 'Setup Paymaster'}
      </button>

      {identity && (
        <div className="text-sm text-gray-600">
          Identity: {identity.commitment.toString().slice(0, 10)}...
        </div>
      )}
    </div>
  )
}
```

## Step 8: Transaction Execution

### Create Transaction Hook

```typescript
// hooks/use-contract-transactions.ts
import { useState } from 'react'

export function useContractTransactions(smartAccountClient: any) {
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  const executeTransaction = async (contractAddress: string, functionName: string, args: any[] = []) => {
    if (!smartAccountClient) {
      throw new Error('Smart account not initialized')
    }

    setIsLoading(true)
    setError(null)

    try {
      // Execute transaction with paymaster
      const txHash = await smartAccountClient.writeContract({
        address: contractAddress,
        abi: YOUR_CONTRACT_ABI,
        functionName,
        args
      })

      // Wait for confirmation
      const receipt = await smartAccountClient.waitForUserOperationReceipt({
        hash: txHash
      })

      return {
        userOpHash: txHash,
        transactionHash: receipt.receipt.transactionHash
      }

    } catch (err) {
      setError((err as Error).message)
      throw err
    } finally {
      setIsLoading(false)
    }
  }

  return {
    executeTransaction,
    isLoading,
    error
  }
}
```

## Step 9: Complete App Structure

### Main App Component

```typescript
// app/page.tsx
'use client'

import { PaymasterProvider, usePaymaster } from '@/context/PaymasterContext'
import { useSmartAccount } from '@/hooks/use-smart-account'
import { useContractTransactions } from '@/hooks/use-contract-transactions'
import { PaymasterSetup } from '@/components/PaymasterSetup'

function DAppContent() {
  const { isConfigured, paymasterConfig } = usePaymaster()
  const { smartAccountClient, isLoading, accountAddress } = useSmartAccount(paymasterConfig)
  const { executeTransaction, isLoading: isTxLoading } = useContractTransactions(smartAccountClient)

  const handleTransaction = async () => {
    try {
      const result = await executeTransaction(
        '0xYourContractAddress',
        'yourFunctionName',
        []
      )
      console.log('Transaction successful:', result)
    } catch (error) {
      console.error('Transaction failed:', error)
    }
  }

  if (!isConfigured) {
    return <PaymasterSetup />
  }

  if (isLoading) {
    return <div>Setting up smart account...</div>
  }

  return (
    <div className="space-y-4">
      <div>Smart Account: {accountAddress}</div>
      
      <button 
        onClick={handleTransaction}
        disabled={isTxLoading}
      >
        {isTxLoading ? 'Executing...' : 'Execute Transaction'}
      </button>
    </div>
  )
}

export default function App() {
  return (
    <PaymasterProvider>
      <DAppContent />
    </PaymasterProvider>
  )
}
```

## Step 10: Pool Membership

### Check if Identity is Pool Member

```typescript
// hooks/use-pool-membership.ts
import { useEffect, useState } from 'react'
import { SubgraphClient } from '@prepaid-gas/data'
import { Identity } from '@semaphore-protocol/identity'

export function usePoolMembership(identity: Identity | null, paymasterAddress: string) {
  const [isMember, setIsMember] = useState(false)
  const [isLoading, setIsLoading] = useState(false)

  useEffect(() => {
    if (identity && paymasterAddress) {
      checkMembership()
    }
  }, [identity, paymasterAddress])

  const checkMembership = async () => {
    if (!identity) return

    setIsLoading(true)

    try {
      const client = SubgraphClient.createForNetwork(84532)
      
      const deposits = await client.query()
        .activities()
        .byType('DEPOSIT')
        .byPaymaster(paymasterAddress)
        .execute()

      const commitment = identity.commitment.toString()
      const isMember = deposits.some(deposit => 
        deposit.commitment?.toString() === commitment
      )

      setIsMember(isMember)
    } catch (error) {
      console.error('Failed to check membership:', error)
    } finally {
      setIsLoading(false)
    }
  }

  return { isMember, isLoading, checkMembership }
}
```

## Key Points

### Error Handling
- Always wrap paymaster operations in try-catch
- Check smart account initialization before transactions
- Validate identity and context before operations

### Performance Tips  
- Cache paymaster clients by network
- Reuse smart account clients when possible
- Use gas estimation before real transactions

### Security Considerations
- Store identities securely (consider encryption)
- Validate paymaster addresses from trusted sources
- Use secure RPC endpoints for production

## Next Steps

- **[React Integration](/guides/react-setup)** - React-specific patterns
- **[Privacy Best Practices](/guides/privacy)** - Optimize privacy and security